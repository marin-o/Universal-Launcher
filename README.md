# Universal-Launcher
Universal Launcher е програма инспирирана од популарниот [Steam](store.steampowered.net) од компанијата Valve. Како и преку нивниот launcher, и преку нашиот се вклучуваат разни апликации и програми. Разликата е во тоа што во Steam не може(всушност, .exe може но не е тоа главната намена) да се додаваат секакви апликации(.еxe), шорткати(.lnk) и линк-шорткати(.url). 
Дополнитечлно, нашата апликација овозможува додавање на подапликации на секоја апликација. На пример, можете да го додатете Steam, а како подапликации сите програми, т.е. десктоп шорткати кои сте ги купиле на Steam. Или да го додадете Visual Studio, па потоа директориумот на некој проект кој го работите во Visual Studio, и кога ќе се обидете да го отворите тој директориум, Universal Launcher го стартува Visual Studio директно во директориумот.

Дополнителни работи кои ги нуди UL се to-do список, notes, и секако додавање на некоја апликација во омилени, за побрз пристап преку homepage.
На корисникот му се овомозможува и креација на свои категории со кои може уште повеќе да си го организира својот workflow.

## Упатство на употреба
![Login](/userguide%20images/login.png)
Кога корисникот прв пат ќе ја стартува програмата, треба да внесе свој username кој потоа при секое вклучување ќе треба да го користи доколку сака да му се прикажат сите негови апликации, notes и to-dos.
**Корисничкото име мора да биде само алфанумерички карактери**

Потоа корисникот ќе се сретне со Homepage:

![Homepage](/userguide%20images/homepage.png)
Во Homepage-от корисникот може да додаде нов Note или Reminder(To-do), со клик на соодветните копчиња во секој панел, со што се отвора нова форма за внес. Исто така тука се присутни и омилените апликации, кои со двоклик на секоја икона може да се вклучи соодветната апликација.
На левата страна од апликациајта стои sidebar, на кој се прикажуваат последните 5 вклучени програми, Pinned note, и копија од табелата за потсетници. На дното од sidebar-от стои копче за менување помеѓу dark mode и light mode. Иницијално вклучен е dark mode.
За да се пинува одреден Note, се употребува двоклик на името негово во ListBox-от за Notes.
За да се едитира постоечки Note, тој само се селектира во ListBox-от и се пишува во RichTextBox-от
Со клик на Library се префрла корисникот во Library: 
![Library empty](/userguide%20images/libraryempty.png)
Library е делот каде корисникот може да додава свои програми со клик на копчето +, со што му е отвара OpenFileDialog:
![OpenFileDialog](/userguide%20images/ofd.png)

### Напомена
*Доколку корисникот сака да додаде .url тип на фајл, мора да избере Internet Shortcut во менито во долниот десен агол*
![Main App](/userguide%20images/librarymainapp.png)
Кога ќе притисне ОК во OFD, се додава картичка со информации за MainApp и дополнителни функционалности: ComboBox за додавање под-апликации и delete, favorite и add category копчиња.

Првите две копчиња се самообјаснувачки, додека последното копче предизвикува да се појави TextBox за додавање категорија. Со притискање Enter се сетира таа категорија врз целата картичка, по што корисникот ќе може да ги сортира според катгорија сите картички, со избирање на соодветната категорија од ComboBox-от лоциран покрај Search bar-от во десниот горен агол.
Ако корисникот сака да ја смени категоријата, тогаш го користи истото копче. Доколку сака да ја тргне, тогаш внесува *none*(case insensitive). Доколку сака да се откаже од промена, притиска escape додека е активен textbox-от

Со бирање опција во ComboBox-от, се отвара OFD или FolderBrowserDialog, зависно од опцијата. Ова функционира исто како и претходно.
![Sub app](/userguide%20images/librarysubapp.png)
Со двоклик на името од секоја аплкација, тоа може да се промени. Enter и escape функционираат исто како и претходно.
Со двоклик на иконата од секоја апликација, таа се вклучува. Доколку е главна апликација таа се додава во recently used, од каде може повторно да се вклучи(двоклик).

Кога корисникот ќе ја исклучи програмата, таа автоматски ги серијализира сите податоци во три датотеки лоцирани во тековниот директориум од каде е вклучена програмата, со име чиј формат е: apps/notes/reminders-*username*.ul. Дополнително, се серијализира и состојбата на dark/light mode.
Десеријализацијата работи, секако, во обратна насока.

## Опис на структурата на проектот
### Nu-Get Packages
Корисни Nu-Get пакети кои ги вклучивме во проектот се:
* [MetroModernUI(MetroFramework)](https://www.nuget.org/packages/MetroModernUI/1.4.0) - Доста детален редизјан на Winforms во помодерен, Windows8 стил. Под MIT лиценца поради која и нашиот проект го ставивме под неа.
* [FontAwesome.Sharp](https://www.nuget.org/packages/FontAwesome.Sharp) - Контроли кои овмозможуваат користење на огромна колекција од икончиња (на пример копчињата кои ги имаме на неколку места во Library page)

Сите податоци за кои е потребна серијализација се чуваат во три класи-репозиториуми: `AppRepository`, `NotesRepository` и `RemindersRepository`.
Во секоја од овие класи се чува листа(или листи во случај на `AppRepository`) од соодветните објекти. Во `AppRepository` има дополнителни листи за последно користени апликации, омилени апикации и сл.

Главната структура на проектот, односно апликациите, имаат една апстрактна суперкласа App, во која се дефинирани одредени членови и методи кои мора да ги има секоја апликација, како и `Launch()` и `ToString()` методи.
Класите кои наследуваат од оваа се `MainApp` и `SubApp`. MainApp дополнително чуваат листа од `SubApps`, додека `SubApps` го чуваат и својот тип, односно инстанца од енумерацијата `SubAppType`. Доколку типот е Folder, тие се вклучуваат со тоа што на нивниот parent MainApp, освен што го вклучуваат, како аругмент ја праќаат локацијата од директориумот.

За инстанцирање на апликациите искористивме `Abstract Factory` design pattern, каде имаме еден интерфејс `IAppFactory`, кој го имплементираат две фабрики за двата вида апликации. 
Имаме и статичка класа AppUtilities, каде имаме разни методи без кои програмата не може да функционира. Тука постојат и двете статички инстанци од фабриките.

Најбитниот метод во класата `AppUtilities`, `GetAppInfo(string path)`, го зема селектираниот пат од OFD/FBD, и идентификува прво дали е .lnk/.exe/.url или директориум, по што доколку е првото, го користи `Icon.ExtractAssociatedIcon()` методот за да ја екстрахира иконата, или доколку е директориум му доделува предефинирана икона. Овој метод враќа инстанца од тип AppInfo, каде се зачувани екстрахираните податоци.

Други битни методи се методите за креирање на нова `MainApp` картичка, или картички за `SubApp`. Двата метода фунцкионираат на сличен принцип, прво отварајќи соодветен дијалог, и потоа повикувајќи го горенаведениот метод, на повикувачот му враќаат соодветен `UserControl`, исполнет со информациите складирани во `AppInfo` објектот.

Метод кој главно се користи при десеријализација, кој е всушност некаков вид на workaround на проблемот до кој наидовме при десеријализација каде боите од иконите на сите апликации беа чудни/корумпирани, е методот `RedrawIcons(AppUserControl)`, кој, зедно со параметризираниот конструктор во `AppUserControl` (големите картички), ги регенерираат сите икончиња од сите апликации. За жал, не најдовме workaround за корупцијата на боите при додавање на омилени апликации.

Друг дел од проектот кој ни беше доста интересен и би сакале да го опишеме е користењето на custom EventHandlers при промена на категорија, вклучување на (main) апликација и бришење на картичка.
Во AppUserControl се чуваат инстанци од 
```
public event EventHandler AppDeleted; 
public event EventHandler<App> AppLaunched;
public event EventHandler<string> CategoryChanged;
```
При креација или десеријализација, во главниот Form, ги додаваме евентите за секој Handler, а во AppUserControl им правиме Invoke. Користењето на `EventHandler` и `EventHandler<TEventArgs>` многу нè научи за тоа како функционираат евентите во C#.

![License](./LICENSE.txt)
